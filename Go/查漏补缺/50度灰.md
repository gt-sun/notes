http://colobu.com/2015/09/07/gotchas-and-common-mistakes-in-go-golang/


## 失败的类型断言

```go
func bad() {
    var data interface{} = "hello"
    if data, ok := data.(int); ok {
        fmt.Println("is INT", data)
    } else {
        fmt.Println("not INT", data) #断言错误，会变为0
    }

}

func good() {
    var data interface{} = "hello"
    if res, ok := data.(int); ok {
        fmt.Println("is INT", res)
    } else {
        fmt.Println("not INT", data) #使用原值
    }

}

func main() {
    bad()
    good()
}
```

输出：

```
not INT 0
not INT hello
```


## 从一组目标中获取第一个结果


```go
func First(query string, replicas ...Search) Result {  
    c := make(chan Result)
    searchReplica := func(i int) { c <- replicas[i](query) }
    for i := range replicas {
        go searchReplica(i)
    }
    return <-c
}
```

这个函数在每次搜索重复时都会起一个 goroutine。每个 goroutine 把它的搜索结果发送到结果的 channel 中。结果 channel 的第一个值被返回。

那其他 goroutine 的结果会怎样呢？还有那些 goroutine 自身呢？

在`First()`函数中的结果 channel 是没缓存的。这意味着只有第一个 goroutine 返回。其他的 goroutine 会困在尝试发送结果的过程中。这意味着，如果你有不止一个的重复时，每个调用将会泄露资源。

为了避免泄露，你需要确保所有的 goroutine 退出。一个不错的方法是使用一个有足够保存所有缓存结果的 channel。

```go
func First(query string, replicas ...Search) Result {  
    c := make(chan Result,len(replicas))
    searchReplica := func(i int) { c <- replicas[i](query) }
    for i := range replicas {
        go searchReplica(i)
    }
    return <-c
}
```

另一个不错的解决方法是使用一个有 default 情况的 select 语句和一个保存一个缓存结果的 channel。default 情况保证了即使当结果 channel 无法收到消息的情况下，goroutine 也不会堵塞。

```go
func First(query string, replicas ...Search) Result {  
    c := make(chan Result,1)
    searchReplica := func(i int) { 
        select {
        case c <- replicas[i](query):
        default:
        }
    }
    for i := range replicas {
        go searchReplica(i)
    }
    return <-c
}
```

## Map的值是无法取址的

```GO
type data struct {
    Name string
}

func modify_map() {
    var t = map[string]int{"age": 12}
    fmt.Println(t)
    t["age"] = 13
    fmt.Println(t)
}

func modify_map_with_struct() {
    var t = map[string]data{"x": {Name: "Sun"}}
    fmt.Println(t)
    t["x"].Name = "Tim"
    fmt.Println(t)
}

func modify_slice_with_struct() {
    var t = []data{{Name: "Sun"}}
    fmt.Println(t)
    t[0].Name = "Tim"
    fmt.Println(t)
}

func main() {
    modify_map() //ok
    modify_map_with_struct() //error
    modify_slice_with_struct() //ok,slice 元素是可以取址的。
}
```

2个办法使`modify_map_with_struct()`函数生效：

1. 使用临时变量

    ```go
    m := map[string]data {"x":{"one"}}
    r := m["x"]
    r.name = "two"
    m["x"] = r
    fmt.Printf("%v",m) //prints: map[x:{two}]
    ```

2. 使用指针
    
    ```go
    m := map[string]*data {"x":{"one"}}
    m["x"].name = "two" //ok
    fmt.Println(m["x"]) //prints: &{two}
    ```
