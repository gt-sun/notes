

## 文章链接

- Golang: 错误即值 Errors are values
http://vnzmi.com/2016/06/22/golang-errors-are-values/

- Golang 的方法集继承规则示例  
http://blog.jobbole.com/107613/

- 十条有用的 GO 技术
http://mikespook.com/2014/07/%E5%8D%81%E6%9D%A1%E6%9C%89%E7%94%A8%E7%9A%84-go-%E6%8A%80%E6%9C%AF/



## 包管理工具对比

from： http://www.grdtechs.com/2016/05/24/comparison-of-Go-Vendoring-Tools/

- godep,govendor,glide 都可以很好的进行包管理。govendor,glide提供的可操作命令更丰富。
- godep 会在根目录生成Godeps和vendor两个文件夹; govendor把所有信息都生成在vendor目录下; glide 会在根目录下生成glide.yaml, glide.lock文件及vendor目录; 从简洁度和尽量不污染项目来看，govendor最优，glide次之。
- godep, govendor, glide 都提供 get 第三方包的命令，但是 glide的glide install 最为方便， 并且直接把第三方包 get 到本项目的 vendor 目录下，并且glide提供的便捷命令也丰富。

在生产项目中推荐使用govendor, 更简洁; 在试验项目中推荐试用glide, 更方便。

## 数组与切片的区别

A, 数组是固定长度的，所以在创建时要指明长度，而切片长度是可变的，创建时不用标明长度，比如：

    数组：       d1 := [...]int{1, 2, 3}
    切片：       d2 := []int32{}
B, 数组的操作是传值的，有拷贝动作，切片的操作实质是指针操作。如下：

```
    a := [5]int{1, 2, 3, 4, 5}
    b := a
    b[1] = 0
    c := []int{}
    c = a[:]
    c[2] = 9
    fmt.Println(a)
    fmt.Println(b) 
    fmt.Println(c)    
```

结果：
            [1 2 9 4 5]
            [1 0 3 4 5]
            [1 2 9 4 5]
b:=a 其实是复制了一份 a 给 b，所以修改 b 不影响 a。c=a[:] 是将 a 的地址传给了 c，所以可以看到结果 a 和 c 是联动的。

总结：切片是引用，必须要基于实体即内存。这个实体可以是数组，也可以是用 make(type, len, cap) 创建的一块类似数组的内存。

## 函数和方法区别

1. 对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然。

2. 对于方法（如 struct 的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以。



## new 和 make

由 new 生成的指针指向了特定的内存，它是不变的。而由 make 生成的内存块大小是可变的，当切片的增长超出了 cap 指定的大小时，将会重新分配一块更大的内存并将原切片内容复制过去，切片指向了新的内存块，切片原来的内存将会释放并回收。所以切片指向的内存地址是会变的。如果这一切还象指针那样由程序员来管理，难度是很大的。好在 GO 语言中这一切由系统来自动管理，程序员使用切片的名字来引用特定的内容，而不需要知道它们变动到了实际内存的哪块位置。引用的实质是用名字操作代替了指针操作，从而屏蔽与简化了这背后的指针操作复杂性。


new 和 make 均是用于分配内存。

- `new(T)` 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为 * T 的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &T{}。
- `make(T)` 返回一个类型为 T 的初始值，它只适用于 3 种内建的引用类型：切片、map 和 channel。它比 new 进行更多的工作。

换言之，new 函数分配内存，make 函数初始化；

## 三种引号的区别

Go 语言的字符串类型string在本质上就与其他语言的字符串类型不同：

- Java 的 String、C++ 的 std::string 以及 Python3 的 str 类型都只是定宽字符序列
- Go 语言的字符串是一个用 UTF-8 编码的变宽字符序列，它的每一个字符都用一个或多个字节表示

即：**一个 Go 语言字符串是一个任意字节的常量序列。**

Golang 的双引号和反引号都可用于表示一个常量字符串，不同在于：

- 双引号用来创建可解析的字符串字面量 (支持转义，但不能用来引用多行)
- 反引号用来创建原生的字符串字面量，这些字符串可能由多行组成 (不支持任何转义序列)，原生的字符串字面量多用于书写多行消息、HTML 以及正则表达式

而单引号则用于表示 Golang 的一个特殊类型：`rune`，即int32类型。


## 方法命名大小写  可见性规则

小写可以理解为private私有，外部是不能调用的；
大写可以理解为publish公有，可以被外部调用；


## 数字类型

**Go 语言中没有 float 类型。**

`int` 型是计算最快的一种类型，是通用数据类型，会根据系统平台(32/64)自动选择。

整型的零值为 0，浮点型的零值为 0.0。

`float32` 精确到小数点后 7 位，`float64` 精确到小数点后 15 位。

浮点数除以 0.0 会返回一个无穷尽的结果，使用 `+Inf` 表示。


## 格式化说明符

链接：https://github.com/polaris1119/The-Golang-Standard-Library-by-Example/blob/master/chapter01/01.3.md

在格式化字符串里，`%d` 用于格式化整数（%x 和 %X 用于格式化 16 进制表示的数字），`%g` 用于格式化浮点型（%f 输出浮点数，%e 输出科学计数表示法），%0d 用于规定输出定长的整数，其中开头的数字 0 是必须的。

`%n.mg` 用于表示数字 n 并精确到小数点后 m 位。

格式化说明符 `%c` 用于表示字符；当和字符配合使用时，`%v` 或 `%d` 会输出用于表示该字符的整数；`%U` 输出格式为 U+hhhh 的字符串

`%p` 用于打印内存指针地址，只能使用`fmt.Printf`

`%t` 用于bool类型

`%s`  普通字符串

`%v`：默认格式



