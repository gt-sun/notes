## 安装

```
# 下载安装包
wget https://storage.googleapis.com/golang/go1.6.3.linux-amd64.tar.gz
# 解压到 /usr/local（或者也可以解压到自定义目录，就是需要对应配置一下路径）
sudo tar -C /usr/local -xzf go1.6.3.linux-amd64.tar.gz
# 更新 PATH 环境变量，在 ~/.bashrc 中添加下面这行
export PATH=$PATH:/usr/local/go/bin
# 启用更新
source ~/.bashrc
# 检测版本
go version
```

如果最后一条命令会显示 go 版本，那么第一步配置就完成了。

我们需要配置 `$GOPATH` 这个环境变量，这个变量类似于指定 Go 项目的 workspace，比方说新建一个 `~/Go` 文件夹，然后在 `~/.bashrc` 中添加 `export GOPATH=$HOME/Go` 即可（别忘了 `source ~/.bashrc`）

- 关于`GOPATH`和`GOROOT`
GOROOT is for compiler/tools that comes from go installation.
GOPATH is for your own go projects / 3rd party libraries (downloaded with "go get").

## Hello world

```go
package main
import "fmt" //引入fmt库
func main() {
    fmt.Println("Hello World!")
}
```

执行 `go run hello.go` 就可以看到输出了

从这个简单的程序中，我们知道：

- 非注释的第一行代码定义包名，每个程序属于一个 package。每个 Go 应用都包含一个名为 `main` 的包
- 用 `import` 关键字来引用包，这里的 fmt 包含了格式化输入输出的相关函数
- 用 `func` 关键词来声明函数，而 `main` 函数是每一个可执行程序必须包含的，一般来说会最先执行（有 `init()` 函数除外）
- 和 C 语言一样，用 `//` 来进行单行注释，用 `/* ... */` 来进行多行注释
- 不用分号
- 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）

## 常用命令

Go 已经自带了很多非常好用的工具，也可以通过简单的命令进行调用，当然也可以据此轻松配置自己喜欢的编辑器。完整的命令列表可以通过输入 go 来查看，这里简单介绍一下。

- `go build hello.go` 就可以编译出最终执行文件，这样直接执行 ./hello 就可以看到结果
- `go clean` 可以清理编译后的文件
- `go doc fmt` 可以查看 fmt 包的文档
- `go env` 显示 Go 相关的环境变量
- `go fmt` 利用 gofmt 工具自动排版代码
- `go get` 下载并安装 package
- `go install` 编译并安装 package
- `go list` 列出 package
- `go run hello.go` 编译并运行 Go 程序
- `go test fmt` 测试 fmt package
- `go tool` 运行指定的 Go 工具，包括 addr2line, asm, cgo, compile, cover, dist, doc, fix, link, nm, objdump, pack, pprof, tour, trace, vet, yacc

## 基础入门
这一部分主要介绍 Go 的基础语法，了解了之后就可以进行简单的编程了

### 语法

基本语法其实非常简单清晰，这里直接以要点的形式列出

- 一行一个语句，不用写分号。如果一行写多个语句，需要用分号隔开，但是并不鼓励这种做法
- 标识符的第一个字符必须是字母或者下划线，从第二个开始才能用数字
- Go 中有 25 个关键字：break, default, func, interface, select, case, defer, go, map, struct, chan, else, goto, package, switch, const, fallthrough, if, range, type, continue, for, import, return var
- Go 中有 36 个预定义标识符：append, bool, byte, cap, close, complex, complex64, complex128, uint, uint8, uint16, uint32, uint64, uintptr, copy, false, float32, float64, imag, int, int8, int16, int32, int64, iota, len, make, new, nil, panic, print, println, real, recover, string, true
- 数据类型有以下几种，非常简洁：
    - 布尔型 `bool`，值为 true 或者 false
    - 数字类型 `int`，`float`，原生支持复数，如果后面跟了数字，就是指位数
    - 字符串类型 `string`，用 UTF8 编码
    - 派生类型：指针、数组、结构体、联合、函数、切片、接口、Map、Channel
    - 几个比较特殊的：
        - `byte` 类似 `uint8`
        - `rune` 类似 `int32`
        - `uint` 32 位或 64 位
        - `int` 与 `uint` 大小一样
        - `uintptr` 无符号整型，用于存放一个指针
- 变量声明使用 `var` 关键字，模板为 `var identifier type`，也就是类型在后面，比如
    - `var a int` 标准声明，使用默认值 0
    - `var b int = 10` 声明且赋值
    - `var c = 10` 不指明类型，根据赋值类型自动判断
    - `d := 10` 省略 var 而使用 `:=`，这里的 `d` 不能是已经声明过的
    - 可以用 `&` 来取得值对应的地址（也就是指针），这个后面会详细介绍
- 常量声明使用 `const` 关键字，模板为 `const identifier [type] = value`，其中类型是可选的，比如
    - `const a string = "hello"` 显式定义
    - `const b = "world"` 隐式定义
- 特殊常量 `iota`，每一个 const 出现是会被重置为 0，每出现一次 `iota`，其值会加一，可以用作枚举值，因为文字描述比较模糊，这里给出一个 iota 的用法

```go
package main
import "fmt"
func main() {
    const (
        a = iota
        b = 3 << iota
        c
        d = 100
        e
        f
        g
    )
    
    fmt.Println(a, b, c, d, e, f, g)
}
```
对应的输出为 `0 6 2 100 4 5 6`，请仔细感受一下这个加一的过程