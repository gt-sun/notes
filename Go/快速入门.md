[TOC]


## 安装

```
# 下载安装包
wget https://storage.googleapis.com/golang/go1.6.3.linux-amd64.tar.gz

# 解压到 /usr/local（或者也可以解压到自定义目录，就是需要对应配置一下路径）
sudo tar -C /usr/local -xzf go1.6.3.linux-amd64.tar.gz

# 更新 PATH 环境变量，在 ~/.bashrc 中添加下面这行
export PATH=$PATH:/usr/local/go/bin

# 启用更新
source ~/.bashrc

# 检测版本
go version

# 查看环境变量
go env
```


- 关于`GOPATH`和`GOROOT`
`$GOROOT` 表示 Go 在你的电脑上的安装位置，它的值一般都是 $HOME/go，当然，你也可以安装在别的地方。
`$GOPATH` 默认采用和 `$GOROOT` 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。

根据约定，`GOPATH`下需要建立3个目录：

- bin (存放编译后生成的可执行文件)
- pkg (存放编译后生成的包文件)
- src (存放项目源码)

```
## 本地官网

godoc -http=:8080

## sublime 设置

安装自动格式化插件
`go get golang.org/x/tools/cmd/goimports`

sublime安装`GoSublime`,
然后打开菜单 Preferences -> Package Settings -> GoSublime -> Settings – User

{
  "env": {
    "GOPATH": "$HOME/go" // go项目路径
  },
  "fmt_cmd": ["goimports"]
}
```

## Hello world

```go
package main
import "fmt" //引入fmt库
func main() {
    fmt.Println("Hello World!")
}
```

执行 `go run hello.go` 就可以看到输出了

从这个简单的程序中，我们知道：

- 非注释的第一行代码定义包名，每个程序属于一个 package。每个 Go 应用都包含一个名为 `main` 的包
- 用 `import` 关键字来引用包，这里的 fmt 包含了格式化输入输出的相关函数
- 用 `func` 关键词来声明函数，而 `main` 函数是每一个可执行程序必须包含的，一般来说会最先执行（有 `init()` 函数除外）
- 和 C 语言一样，用 `//` 来进行单行注释，用 `/* ... */` 来进行多行注释
- 不用分号
- 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）

## 常用命令

Go 已经自带了很多非常好用的工具，也可以通过简单的命令进行调用，当然也可以据此轻松配置自己喜欢的编辑器。完整的命令列表可以通过输入 go 来查看，这里简单介绍一下。

- `go build hello.go` 就可以编译出最终执行文件，这样直接执行 ./hello 就可以看到结果
- `go clean` 可以清理编译后的文件
- `go doc fmt` 可以查看 fmt 包的文档
- `go env` 显示 Go 相关的环境变量
- `go fmt` 利用 gofmt 工具自动排版代码
- `go get` 下载并安装 package
- `go install` 编译并安装 package
- `go list` 列出 package
- `go run hello.go` 编译并运行 Go 程序
- `go test fmt` 测试 fmt package
- `go tool` 运行指定的 Go 工具，包括 addr2line, asm, cgo, compile, cover, dist, doc, fix, link, nm, objdump, pack, pprof, tour, trace, vet, yacc

## 基础入门
这一部分主要介绍 Go 的基础语法，了解了之后就可以进行简单的编程了

### 语法

基本语法其实非常简单清晰，这里直接以要点的形式列出

- 一行一个语句，不用写分号。如果一行写多个语句，需要用分号隔开，但是并不鼓励这种做法
- 标识符的第一个字符必须是字母或者下划线，从第二个开始才能用数字
- Go 中有 25 个关键字：break, default, func, interface, select, case, defer, go, map, struct, chan, else, goto, package, switch, const, fallthrough, if, range, type, continue, for, import, return var
- Go 中有 36 个预定义标识符：append, bool, byte, cap, close, complex, complex64, complex128, uint, uint8, uint16, uint32, uint64, uintptr, copy, false, float32, float64, imag, int, int8, int16, int32, int64, iota, len, make, new, nil, panic, print, println, real, recover, string, true
- 数据类型有以下几种，非常简洁：
    - 布尔型 `bool`，值为 true 或者 false
    - 数字类型 `int`，`float`，原生支持复数，如果后面跟了数字，就是指位数
    - 字符串类型 `string`，用 UTF8 编码
    - 派生类型：指针、数组、结构体、联合、函数、切片、接口、Map、Channel
    - 几个比较特殊的：
        - `byte` 类似 `uint8`
        - `rune` 类似 `int32`
        - `uint` 32 位或 64 位
        - `int` 与 `uint` 大小一样
        - `uintptr` 无符号整型，用于存放一个指针
- 变量声明使用 `var` 关键字，模板为 `var identifier type`，也就是类型在后面，比如
    - `var a int` 标准声明，使用默认值 0；同一类型的多个变量可以声明在同一行，如：`var a, b, c int`
    - `var b int = 10` 声明且赋值
    - `var c = 10` 不指明类型，根据赋值类型自动判断
    - `d := 10` 省略 var 而使用 `:=`，这里的 `d` 不能是已经声明过的
    - 多变量可以在同一行进行赋值，`a, b, c := 5, 7, "abc"`
    - 如果你想要交换两个变量的值，则可以简单地使用 `a, b = b, a`
    - 空白标识符 `_` 也被用于抛弃值，如值 5 在：`_, b = 5, 7` 中被抛弃
    - 可以用 `&` 来取得值对应的地址（也就是指针），这个后面会详细介绍
- 常量是一个简单值的标识符，在程序运行时，**不会被修改的量**。常量声明使用 `const` 关键字，模板为 `const identifier [type] = value`，其中类型是可选的，比如
    - `const a string = "hello"` 显式定义
    - `const b = "world"` 隐式定义
    - 多个相同类型的声明可以简写为：`const c_name1, c_name2 = value1, value2`
    - 常量可以用 `len()`, `cap()`, `unsafe.Sizeof()`常量计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：
```go
package main

import "unsafe"
const (
    a = "abc"
    b = len(a)
    c = unsafe.Sizeof(a)
)

func main(){
    println(a, b, c)
}
```
- 特殊常量 `iota`，每一个 const 出现是会被重置为 0，每出现一次 `iota`，其值会加一，可以用作枚举值

```
const (
    a = iota
    b = iota
    c = iota
)
```

第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 `a=0, b=1, c=2` 可以简写为如下形式：

```
const (
    a = iota
    b
    c
)
```

```go
package main
import "fmt"
func main() {
    const (
        a = iota
        b = 3 << iota
        c
        d = 100
        e
        f
        g
    )
    
    fmt.Println(a, b, c, d, e, f, g)
}
```

对应的输出为 `0 6 2 100 4 5 6`，请仔细感受一下这个加一的过程

```
package main

import "fmt"

func main() {
    const (
            a = iota   //0
            b          //1
            c          //2
            d = "ha"   //独立值，iota += 1
            e          //"ha"   iota += 1
            f = 100    //iota +=1
            g          //100  iota +=1
            h = iota   //7,恢复计数
            i          //8
    )
    fmt.Println(a,b,c,d,e,f,g,h,i)
}
```
以上实例运行结果为：
`0 1 2 ha ha 100 100 7 8`

利用`iota`来打印1024

```go
package main

const (
    B float64 = 1 << (iota * 10)
    KB
    MB
)

func main() {
    println(B, KB, MB)
}
```

### 运算符

Go 的运算符也比较『正常』，这里简单点一下

算术运算符：+, -, *, /, %, ++, --
关系运算符：==, !=, >, <, >=, <=
逻辑运算符：&&, ||, !
赋值运算符：=, +=, -=, *=, /=, %=, <<=, >>=, &=, ^=, |=
位运算符：&, |, ^, <<, >>
其他运算符：&(返回变量的存储地址)，* 指针变量
运算符优先级也没有什么特别的地方，正常用一般不会有太多『意外』

### 条件语句

Go 中的条件语句主要分三种：`if`, `switch` 和 `select`，比较特别的是 `select`，会随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。

#### if

`if` 语句除了没有了 `( )` 之外（甚至强制不能使用它们），看起来跟 C 或者 Java 中的一样，而 `{ }` 是必须的。`if` 语句可以在条件之前执行一个简单的语句。由这个语句定义的变量的作用域仅在 `if` 范围之内。在 `if` 的便捷语句定义的变量同样可以在任何对应的 `else` 块中使用。

```go
package main
import (
    "fmt"
    "math"
)
func sqrt(x float64) string {
    if x < 0 {
        return sqrt(-x) + "i"
    }
    return fmt.Sprint(math.Sqrt(x))
}
func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v < lim {
        return v
    } else {
        fmt.Printf("%g >= %g\n", v, lim)
    }
    // 这里开始就不能使用 v 了
    return lim
}
func main() {
    fmt.Println(sqrt(2), sqrt(-4))
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
}
```

#### switch

- 可以使用任何类型或表达式作为条件语句；
- 不需要写break，一旦条件符合自动终止；如希望继续执行下一个case，需使用fallthrough语句；
- 支持一个初始化表达式（可以是并行方式），右侧需跟分号；
- 左大括号必须和条件语句在同一行；

switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。。

Go 编程语言中 switch 语句的语法如下：

```go
switch var1 {
    case val1:
        ...
    case val2:
        ...
    default:
        ...
}
```

变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，**但必须是相同的类型**；或者最终结果为相同类型的表达式。
您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：`case val1, val2, val3`。

实例：

```go
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var grade string = "B"
   var marks int = 90

   switch marks {
      case 90: grade = "A"
      case 80: grade = "B"
      case 50,60,70 : grade = "C"
      default: grade = "D"  
   }

   switch {
      case grade == "A" :
         fmt.Printf("优秀!\n" )     
      case grade == "B", grade == "C" :
         fmt.Printf("良好\n" )      
      case grade == "D" :
         fmt.Printf("及格\n" )      
      case grade == "F":
         fmt.Printf("不及格\n" )
      default:
         fmt.Printf("差\n" );
   }
   fmt.Printf("你的等级是 %s\n", grade );      
}

```

以上代码执行结果为：
优秀!
你的等级是 A

switch 语句的第二种形式是不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件。当任一分支的测试结果为 true 时，该分支的代码会被执行。提供了可读性更好的书写方式。

```
switch {
    case condition1:
        ...
    case condition2:
        ...
    default:
        ...
}
```

**Type Switch**

switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。
Type Switch 语法格式如下：

```
switch x.(type){
    case type:
       statement(s);      
    case type:
       statement(s); 
    /* 你可以定义任意个数的case */
    default: /* 可选 */
       statement(s);
}
```

实例：

```
package main

import "fmt"

func main() {
   var x interface{}
     
   switch i := x.(type) {
      case nil:   
         fmt.Printf(" x 的类型 :%T",i)                
      case int:   
         fmt.Printf("x 是 int 型")                       
      case float64:
         fmt.Printf("x 是 float64 型")           
      case func(int) float64:
         fmt.Printf("x 是 func(int) 型")                      
      case bool, string:
         fmt.Printf("x 是 bool 或 string 型" )       
      default:
         fmt.Printf("未知型")     
   }   
}
```

以上代码执行结果为：
`x 的类型 :<nil>`


#### select

select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。例如

```go
package main
import "fmt"
func main() {
   var c1, c2, c3 chan int
   var i1, i2 int
   select {
      case i1 = <-c1:
         fmt.Printf("received ", i1, " from c1\n")
      case c2 <- i2:
         fmt.Printf("sent ", i2, " to c2\n")
      case i3, ok := (<-c3):  // same as: i3, ok := <-c3
         if ok {
            fmt.Printf("received ", i3, " from c3\n")
         } else {
            fmt.Printf("c3 is closed\n")
         }
      default:
         fmt.Printf("no communication\n")
   }    
}
```
以上代码执行结果为：
no communication

其中：

- 每个 case 都必须是一个通信
- 所有 channel 表达式都会被求值
- 所有被发送的表达式都会被求值
- 如果任意某个通信可以进行，它就执行；其他被忽略。
- 如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。否则：
    - 如果有 default 子句，则执行该语句。
    - 如果没有 default 字句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。


### 循环语句

Go 只有一种循环结构——for 循环。基本的 for 循环除了没有了 ( ) 之外（甚至强制不能使用它们），看起来跟 C 或者 Java 中做的一样，而 { } 是必须的。跟 C 或者 Java 中一样，可以让前置、后置语句为空。基于此可以省略分号：C 的 while 在 Go 中叫做 for。如果省略了循环条件，循环就不会结束，因此可以用更简洁地形式表达死循环。

**特别注意，永远不要在循环体内修改计数器，这在任何语言中都是非常差的实践！**

```go
package main
import "fmt"
func main() {
    sum := 0
    for i := 0; i < 10; i++ {
        sum += i
    }
    fmt.Println(sum)
    
    sum := 1
    for ; sum < 1000; {
        sum += sum
    }
    fmt.Println(sum)
    
    sum := 1
    for sum < 1000 {
        sum += sum
    }
    fmt.Println(sum)
    
    for {
    }
}
```


*for-range 结构*

一般形式为：for ix, val := range coll { }。

要注意的是，val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值（译者注：如果 val 为指针，则会产生指针的拷贝，依旧可以修改集合中的原值）。

### break、goto、continue语句

跳出多层循环：

```
package main

func main() {
LABEL:
    for {
        for a := 0; a < 3; a++ {
            println(a)
            break LABEL
        }
    }
    println("ok")
}
```

同样的效果使用goto：

```
package main

func main() {

    for {
        for a := 0; a < 3; a++ {
            println(a)
            goto LABEL
        }
    }
LABEL:
    println("ok")
}
```

`continue`语句：

```
package main

func main() {
LABEL:
    for i := 0; i < 5; i++ {
        for {
            println(i)
            continue LABEL
        }
    }
    println("Over")  # 1 2 3 4 Over
}
```

## 进阶概念

### 函数 / 匿名函数

- 函数可以没有参数或接受多个参数，注意类型名在变量名之后。
- 当两个或多个连续函数的命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。
- 在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显示的指出指针）。

Go 的返回值可以被命名，并且像变量那样使用。返回值的名称应当具有一定的意义，可以作为文档使用。没有参数的 return 语句返回结果的当前值。也就是直接返回。直接返回语句仅应当用在像下面这样的短函数中。在长的函数中它们会影响代码的可读性。

在函数中，`:=` 简洁赋值语句在明确类型的地方，可以用于替代 `var` 定义。函数外的每个语句都必须以关键字开始（`var`、`func`、等等），`:=` 结构不能使用在函数外。

```go
package main

import (
    "fmt"
)

func A() (a, b, c int) {
    a, b, c = 1, 2, 3 // 这里不需要用:= ，因为上面已经初始化了
    return a, b, c  // a, b, c 可以省略，但为了提高可读性还是加上

}

func main() {
    x, y, z := A()
    fmt.Println(x, y, z)
}
```

不定长变参：`func A(a ...int)`，a变为一个slice。如果还有其他变参，必须放在不定长变参前面


值类型和引用类型作为传参的区别：

```go
func A(a int) {
    a = 2
    fmt.Println(a)
}

func main() {
    a := 1
    A(a)
    fmt.Println(a)
}

// 打印
2
1
```

```go
func A(s []int) {
    s[0] = 4
    s[1] = 5
    s[2] = 6
    fmt.Println(s)
}

func main() {
    s1 := []int{1, 2, 3}
    A(s1)
    fmt.Println(s1)
}

// 打印
[4 5 6]
[4 5 6]
```

**结论：**引用类型会改变，因为是同一个内存地址。

如果也想改变值类型，可以利用指针：

```go
func A(a *int) {
    *a = 2
    fmt.Println(*a)
}

func main() {
    a := 1
    A(&a)
    fmt.Println(a)
}

// 打印
2
2
```

**匿名函数**

不能作为外层函数！

```go
func main() {
    a := func() {
        fmt.Println("这是一个匿名函数")
    }
    a()
}
```

**将函数作为返回值**

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    addBmp := MakeAddSuffic(".bmp")
    res := addBmp("file")
    fmt.Println(res)
}

func MakeAddSuffic(suffix string) func(string) string {
    return func(name string) string {
        if !strings.HasSuffix(name, suffix) {
            return name + suffix
        }
        return name
    }
}

// 打印
file.bmp

```

### 数组

创建数组的2种形式：`var a [2]int` 和 `a := [2]int{1,2}`

类型 `[n]T` 是一个有 n 个类型为 T 的值的数组。表达式 `var a [10]int` 定义变量 a 是一个有十个整数的数组。数组的长度是其类型的一部分，因此数组不能改变大小。 这看起来是一个制约，但是请不要担心； Go 提供了更加便利的方式来使用数组。

```go
package main
import "fmt"
func main() {
    var a [2]string
    a[0] = "Hello"
    a[1] = "World"
    fmt.Println(a[0], a[1])
    fmt.Println(a)
}
```

- 创建一个包含9个0 1个1的数组： `a := [10]int{9: 1}` ，表示索引为9的值为1，或者`a := [...]int{9: 1}`
- 使用这种形式忽略数组的长度： `a := [...]int{1,2,3}`
- 使用索引创建数组： `a := [...]string{0: "aa", 1: "bb", 2: "cc"}`

*指针数组：*

```
func main() {
    x, y := 1, 2
    a := [...]*int{&x, &y}
    fmt.Println(a)  # [0xc0420381d0 0xc0420381d8]
}
```

**数组可以使用`==` `!=`进行比较**

*使用`new`创建的数组是一个指向该数组的指针：*

```
func main() {
    a := new([5]int)
    fmt.Println(a)  # &[0 0 0 0 0]
}
```

*多维数组：*

```
a := [2][3]int{
        {1, 1, 1},
        {2, 3, 3}}
```



### 指针

Go 具有指针。 指针保存了变量的内存地址。

类型 `*T` 是指向类型 `T` 的值的指针。其零值是 `nil`。


`&` 符号会生成一个指向其作用对象的指针。
`*` 符号表示指针指向的底层的值。

```
i := 42
var p = &i
```


```
fmt.Println(*p) // 通过指针 p 读取 i
*p = 21         // 通过指针 p 设置 i
```

获取a的指针：

```
package main

func main() {

    a := 1
    var p *int = &a  // 这里*int可以省略
    println(p)  // 0xc04202df20
    println(*p)  // 1
}
```

这也就是通常所说的 “间接引用” 或 “非直接引用”。与 C 不同，Go 没有指针运算。

```go
package main
import "fmt"
func main() {
    i, j := 42, 2701
    p := &i         // point to i
    fmt.Println(*p) // read i through the pointer
    *p = 21         // set i through the pointer
    fmt.Println(i)  // see the new value of i
    p = &j         // point to j
    *p = *p / 37   // divide j through the pointer
    fmt.Println(j) // see the new value of j
}
```

### 结构体

一个结构体（`struct`）就是一个字段的集合。（而 type 的含义跟其字面意思相符。）结构体字段使用点号来访问。结构体字段可以通过结构体指针来访问。通过指针间接的访问是透明的。

创建：

```go
// 1
type persion struct{}

func main() {
    p := persion{}
    fmt.Println(p)
}


// 2
type persion struct {
    Name string
    Age  int
}

func main() {
    p := persion{
        Name: "Joe",
        Age:  23,
    }
    fmt.Println(p)
}

// 3
func main() {
    fmt.Println(persion{"Joe", 22})
}
```

```
package main
import "fmt"
type Vertex struct {
    X int
    Y int
}
func main() {
    fmt.Println(Vertex{1, 2})
    v := Vertex{1, 2}
    v.X = 4
    fmt.Println(v.X)
    
    p := &v
    p.X = 1e9
    fmt.Println(v)
}
```

结构体文法表示通过结构体字段的值作为列表来新分配一个结构体。使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）特殊的前缀 `&` 返回一个指向结构体的指针。

```
package main
import "fmt"
type Vertex struct {
    X, Y int
}
var (
    v1 = Vertex{1, 2}  // 类型为 Vertex
    v2 = Vertex{X: 1}  // Y:0 被省略
    v3 = Vertex{}      // X:0 和 Y:0
    p  = &Vertex{1, 2} // 类型为 *Vertex
)
func main() {
    fmt.Println(v1, p, v2, v3)
}
```

`struct`是值拷贝类型，作为传参不会改变原值，请看：

```go
type persion struct {
    Name string
    Age  int
}

func A(p persion) {
    p.Age = 30
    fmt.Println(p)
}

func main() {
    a := persion{"sun", 20}
    fmt.Println(a)
    A(a)
    fmt.Println(a)
}

// 打印
{sun 20}
{sun 30}
{sun 20}
```

如果需要修改原值，使用指针：

```go
type persion struct {
    Name string
    Age  int
}

func A(p *persion) {
    p.Age = 30
    fmt.Println(p)
}

func main() {
    a := &persion{"sun", 20}  // 推荐：a初始化的时候就使用指针
    fmt.Println(a)
    A(a)
    fmt.Println(a)
}

// 打印
{sun 20}
&{sun 30}
{sun 30}
```

**匿名结构体**

如下定义：

```go
func main() {
    a := struct {
        Name string
        Age  int
    }{
        Name: "Joe",
        Age:  20,
    }
    fmt.Println(a)
}
```

结构体的指针，取值的时候不需要使用`*`：

```go
func main() {
    a := &struct {
        Name string
        Age  int
    }{
        Name: "Joe",
        Age:  20,
    }
    fmt.Println(a) // &{Joe 20}
}
```

**多层struct**

```go
type persion struct {
    Name    string
    Age     int
    Contact struct {
        City, Phone string
    }
}

func main() {
    a := persion{Name: "Joe", Age: 20}
    a.Contact.City = "Shanghai"
    a.Contact.Phone = "111213223"
    fmt.Println(a)  // {Joe 20 {Shanghai 111213223}}
}
```

**匿名字段**

```go
type persion struct {
    string
    int
}

func main() {
    a := persion{"Joe", 20}  // 顺序必须一致
    fmt.Println(a)
}
```

`Go`没有继承没有class，通过以下方式：

```go
type human struct {
    Sex int
}

type teacher struct {
    human
    Name string
    Age  int
}

type student struct {
    human
    Name string
    Age  int
}

func main() {
    a := teacher{Name: "sun", Age: 20, human: human{Sex: 0}}
    b := teacher{Name: "sun", Age: 20, human: human{Sex: 1}}
    fmt.Println(a)
    fmt.Println(b)
    a.Age = 30
    a.Sex = 1 // Sex已经嵌套来了，这里可以直接调用
    fmt.Println(a)
}

// 打印
{{0} sun 20}
{{1} sun 20}
{{1} sun 30}
```


### 切片

- 本身并不是数组，它指向底层的数组
- 作为变长数组的代替方案，可以关联底层数组的局部或全部
- 为引用类型
- 可以直接创建或从底层数组获取生成
- `len()`获取元素个数，`cap()`获取容量
- 一般使用`make()`创建
- 如果多个slice指向相同的底层数组，其中一个的值改变会影响到全部
- 优点 ：因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 代码中 切片比数组更常用。
- 一个切片 s 可以这样扩展到它的大小上限：`s = s[:cap(s)]`，如果再扩大的话就会导致运行时错误
- 注意 绝对不要用指针指向 slice。切片本身已经是一个引用类型，所以它本身就是一个指针!!

一个 slice 会指向一个序列的值，并且包含了长度信息。 `[]T` 是一个元素类型为 T 的 slice。slice 可以重新切片，创建一个新的 slice 值指向相同的数组。表达式 `s[lo:hi]` 表示从 lo 到 hi-1 的 slice 元素，含两端。因此 `s[lo:lo]` 是空的，而 `s[lo:lo+1]` 有一个元素。

下面两种方法可以生成相同的切片:

```
make([]int, 50, 100)
new([100]int)[0:50]
```

slice 由函数 make 创建。这会分配一个零长度的数组并且返回一个 slice 指向这个数组： `a := make([]int, 5) // len(a)=5` 为了指定容量，可传递第三个参数到 `make`：

```
b := make([]int, 0, 5) // len(b)=0, cap(b)=5
b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
c = b[:]  // 所有元素
```

如果某个人写：`var slice1 []type = arr1[:]` 那么 slice1 就等于完整的 arr1 数组（所以这种表示方式是 `arr1[0:len(arr1)]`的一种缩写）。另外一种表述方式是：`slice1 = &arr1`。

例子

```go
package main
import "fmt"
func main() {
    a := make([]int, 5)
    printSlice("a", a)
    b := make([]int, 0, 5)
    printSlice("b", b)
    c := b[:2]
    printSlice("c", c)
    d := c[2:5]  # 虽然c只有2个元素，但依然可以取到b后面的元素，因为slice是指向内存地址
    printSlice("d", d)
}
func printSlice(s string, x []int) {
    fmt.Printf("%s len=%d cap=%d %v\n",
        s, len(x), cap(x), x)
}
```

slice 的零值是 `nil`。一个 nil 的 slice 的长度和容量是 0。

```
package main
import "fmt"
func main() {
    var z []int
    fmt.Println(z, len(z), cap(z))
    if z == nil {
        fmt.Println("nil!")
    }
}
```

向 slice 添加元素是一种常见的操作，因此 Go 提供了一个内建函数 `append`。 内建函数的文档对 append 有详细介绍。`func append(s []T, vs ...T) []T`

- append 的第一个参数 s 是一个类型为 T 的数组，其余类型为 T 的值将会添加到 slice。
- append 的结果是一个包含原 slice 所有元素加上新添加的元素的 slice。
- 如果 s 的底层数组太小，而不能容纳所有值时，会分配一个更大的数组。 返回的 slice 会指向这个新分配的数组。

```go
package main
import "fmt"
func main() {
    var a []int
    printSlice("a", a)
    // append works on nil slices.
    a = append(a, 0)
    printSlice("a", a)
    // the slice grows as needed.
    a = append(a, 1)
    printSlice("a", a)
    // we can add more than one element at a time.
    a = append(a, 2, 3, 4)
    printSlice("a", a)
}
func printSlice(s string, x []int) {
    fmt.Printf("%s len=%d cap=%d %v\n",
        s, len(x), cap(x), x)
}
```

for 循环的 range 格式可以对 slice 或者 map 进行迭代循环。可以通过赋值给 `_` 来忽略序号和值。如果只需要索引值，去掉 “, value” 的部分即可。

```
package main
import "fmt"
var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}
func main() {
    for i, v := range pow {
        fmt.Printf("2**%d = %d\n", i, v)
    }
}
```

### Map

- 类似其它语言中的哈希表或者字典，以key-value形式存储数据
- Key必须是支持==或!=比较运算的类型，不可以是函数、map或slice
- Map查找比线性搜索快很多，但比使用索引访问数据的类型慢100倍
- Map使用make()创建，支持 := 这种简写方式

- make([keyType]valueType, cap)，cap表示容量，可省略
- 超出容量时会自动扩容，但尽量提供一个合理的初始值
- 使用len()获取元素个数

- 键值对不存在时自动添加，使用delete()删除某键值对
- 使用 for range 对map和slice进行迭代操作

map 映射键到值。map 在使用之前必须用 make 而不是 new 来创建；值为 nil 的 map 是空的，并且不能赋值。map 的文法跟结构体文法相似，不过必须有键名。如果顶级的类型只有类型名的话，可以在文法的元素中省略键名

创建：

```
// 创建并初始化一些值
m := map[int]string{1: "a", 2: "b", 3: "c", 4: "d", 5: "e"}

// 使用make()
var m map[int]string
m = make(map[int]string)

// 省略make() 
var m map[int]string
m = map[int]string{}

// 一行
var m map[int]string = make(map[int]string) 
或者
m := make(map[int]string)


// 赋值
m := make(map[int]string)
m[1] = "AA"
fmt.Println(m)  // map[1:AA]

// 取值
a := m[1]

// 删除一个key
delete(m, 1)
```

以下实例说明在迭代中间是无法改变sm的值的，因为v是一份拷贝：

```go
package main

import (
    "fmt"
)

func main() {
    sm := make([]map[int]string, 5) // 创建一个元素为map的slice
    for _, v := range sm {
        v = make(map[int]string, 1)
        v[1] = "OK"
        fmt.Println(v)
    }
    fmt.Println(sm)
}

// 打印
map[1:OK]
map[1:OK]
map[1:OK]
map[1:OK]
map[1:OK]
[map[] map[] map[] map[] map[]]
```

如果想要对sm进行操作，则要使用索引：

```go
package main

import (
    "fmt"
)

func main() {
    sm := make([]map[int]string, 5)
    for i := range sm {
        sm[i] = make(map[int]string, 1)
        sm[i][1] = "OK"
        fmt.Println(sm[i])
    }
    fmt.Println(sm)
}

// 打印
map[1:OK]
map[1:OK]
map[1:OK]
map[1:OK]
map[1:OK]
[map[1:OK] map[1:OK] map[1:OK] map[1:OK] map[1:OK]]
```

实例：按照key对Map类型进行排序

```go
package main

import (
    "fmt"
    "sort"
)

func main() {
    m := map[int]string{1: "a", 2: "b", 3: "c", 4: "d", 5: "e"}
    fmt.Println(m) // 无序，每次打印不一样
    s := make([]int, len(m))
    i := 0
    for k, _ := range m {
        s[i] = k
        i++
    }
    sort.Ints(s) // 对s排序
    fmt.Println(s)
    for _, value := range s { // 按照排序后的索引取出m的值
        fmt.Println(m[value])
    }
}
```

在 map m 中插入或修改一个元素：`m[key] = elem`。获得元素：`elem = m[key]`。删除元素：`delete(m, key)`。通过双赋值检测某个键存在：`elem, ok = m[key]` 如果 key 在 m 中，`ok` 为 `true` 。否则， `ok` 为 `false`，并且 elem 是 map 的元素类型的零值。同样的，当从 map 中读取某个不存在的键时，结果是 map 的元素类型的零值。

```go
package main
import "fmt"
func main() {
    m := make(map[string]int)
    m["Answer"] = 42
    fmt.Println("The value:", m["Answer"])
    m["Answer"] = 48
    fmt.Println("The value:", m["Answer"])
    delete(m, "Answer")
    fmt.Println("The value:", m["Answer"])
    v, ok := m["Answer"]
    fmt.Println("The value:", v, "Present?", ok)
}

//
The value: 42
The value: 48
The value: 0
The value: 0 Present? false
```

### defer(析构函数 ) / panic recover

- 执行方式类似其它语言中的析构函数，在函数体执行结束后按照调用顺序的**相反顺序逐个执行**
- 即使函数发生严重错误也会执行
- 支持匿名函数的调用
- 常用于资源清理、文件关闭、解锁以及记录时间等操作
- 通过与匿名函数配合可在return之后修改函数计算结果
- 如果函数体内某个变量作为defer时匿名函数的参数，则在定义defer时即已经获得了拷贝，否则则是引用某个变量的地址
- defer 的用法类似于面向对象编程语言 Java 和 C# 的 `finally` 语句块，它一般用于释放某些已分配的资源。

- Go 没有异常机制，但有 panic/recover 模式来处理错误
- Panic 可以在任何地方引发，但recover只有在defer调用的函数中有效


演示：

```go
func main() {
    function1()
}

func function1() {
    fmt.Printf("In function1 at the top\n")
    defer function2()
    fmt.Printf("In function1 at the bottom!\n")
}

func function2() {
    fmt.Printf("function2: Deferred until the end of the calling function!")
}


//输出：

In Function1 at the top
In Function1 at the bottom!
Function2: Deferred until the end of the calling function!
```


演示1：当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出）：

```go
func main() {
    for i := 0; i < 3; i++ {
        defer fmt.Println(i)
    }
}

// 打印
2
1
0
```

演示2：是一个闭包，等到for循环执行完之后(i是一个地址引用)

```go
func main() {
    for i := 0; i < 3; i++ {
        defer func() {
            fmt.Println(i)
        }()
    }
}

// 打印
3
3
3
```

**使用 defer 语句来记录函数的参数与返回值**

```go
package main

import (
    "io"
    "log"
)

func func1(s string) (n int, err error) {
    defer func() {
        log.Printf("func1(%q) = %d, %v", s, n, err)
    }()
    return 7, io.EOF
}

func main() {
    func1("Go")
}


//
2016/11/10 17:13:19 func1("Go") = 7, EOF
```

- panic 引发异常

```go
func main() {
    A()
    B()
    C()
}

func A() {
    fmt.Println("func A")
}

func B() {
    panic("panic in B") // 执行该行后 引发错误
}

func C() {
    fmt.Println("func in C")
}
```

使用defer 和 recover：

```go
func main() {
    A()
    B()
    C()
}

func A() {
    fmt.Println("func A")
}

func B() {
    defer func() {
        if err := recover(); err != nil {
            fmt.Println("recover in B")
        }
    }()
    panic("panic in B")
}

func C() {
    fmt.Println("func in C")
}

// 打印
func A
recover in B
func in C
```

### 方法

- Go 中虽没有class，但依旧有method
- 通过显示说明receiver来实现与某个类型的组合
- 只能为同一个包中的类型定义方法
- Receiver 可以是类型的值或者指针
- 不存在方法重载
- 可以使用值或指针来调用方法，编译器会自动完成转换
- 从某种意义上来说，方法是函数的语法糖，因为receiver其实就是方法所接收的第1个参数（Method Value vs. Method Expression）
- 如果外部结构和嵌入结构存在同名方法，则优先调用外部结构的方法
- 类型别名不会拥有底层类型所附带的方法
- 方法可以调用结构中的非公开字段



```go
type A struct {
}

func main() {
    a := A{}
    a.print()
}

func (a A) print() {
    fmt.Println("A")
}
```

实例：调用方法+100

```go
type TZ int

func main() {
    var a TZ
    a.Increase(100)
    fmt.Println(a)

}

func (tz *TZ) Increase(num int) {
    *tz += TZ(num) // 这里需要强制转换类型
}
```

### 接口 interface

- 接口是一个或多个方法签名的集合
- 只要某个类型拥有该接口的所有方法签名，即算实现该接口，无需显示声明实现了哪个接口，这称为 Structural Typing
- 接口只有方法声明，没有实现，没有数据字段
- 接口可以匿名嵌入其它接口，或嵌入到结构中
- 将对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针
- 只有当接口存储的类型和对象都为nil时，接口才等于nil
- 接口调用不会做receiver的自动转换
- 接口同样支持匿名字段方法
- 接口也可实现类似OOP中的多态
- 空接口可以作为任何类型数据的容器


```go
type USB interface {
    Name() string
    Connect()
}

type PhoneConnecter struct {
    name string
}

func (pc PhoneConnecter) Name() string {
    return pc.name
}

func (pc PhoneConnecter) Connect() {
    fmt.Println("Connect:", pc.name)
}

func main() {
    var a USB
    a = PhoneConnecter{"PhoneConnect"}
    a.Connect()
    Disconnect(a)
}

func Disconnect(usb USB) {
    if pc, ok := usb.(PhoneConnecter); ok {
        fmt.Println("Disconnect:", pc.name)
        return
    }
    fmt.Println("Unknown device.")
}
```

上面`Disconnect`可以改写为：

```go
func Disconnect(usb interface{}) { //空接口
    switch v := usb.(type) {
    case PhoneConnecter:
        fmt.Println("Disconnect:", v.name)
    default:
        fmt.Println("Unknown device.")

    }
}
```

### 反射 reflection

- 反射可大大提高程序的灵活性，使得 interface{} 有更大的发挥余地
- 反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息
- 反射会将匿名字段作为独立字段（匿名字段本质）
- 想要利用反射修改对象状态，前提是 interface.data 是 settable，即 pointer-interface
- 通过反射可以“动态”调用方法

实例：

```go
package main

import (
    "fmt"
    "reflect"
)

type User struct {
    ID   int
    Name string
    Age  int
}

func (u User) Hello() {
    fmt.Println("Hello world.")
}

func main() {
    u := User{1, "ok", 22}
    Info(u)
}

func Info(o interface{}) {
    t := reflect.TypeOf(o)
    fmt.Println("Type:", t.Name())

    v := reflect.ValueOf(o)
    fmt.Println("Fields:")

    for i := 0; i < t.NumField(); i++ {
        f := t.Field(i)
        val := v.Field(i).Interface()
        fmt.Printf("%6s:%v = %v\n", f.Name, f.Type, val)
    }

    for i := 0; i < t.NumMethod(); i++ {
        m := t.Method(i)
        fmt.Printf("%6s: %v\n", m.Name, m.Type)
    }
}

// 打印
Type: User
Fields:
    ID:int = 1
  Name:string = ok
   Age:int = 22
 Hello: func(main.User)
```


通过反射`ValueOf`修改值：

```go
import (
    "fmt"
    "reflect"
)

func main() {
    a := 123
    v := reflect.ValueOf(&a)
    v.Elem().SetInt(999)

    fmt.Println(a)
}
```

修改结构里面的值：

```go
package main

import (
    "fmt"
    "reflect"
)

type User struct {
    Id   int
    Name string
    Age  int
}

func main() {
    u := User{1, "OK", 20}
    Set(&u)
    fmt.Println(u)
}

func Set(o interface{}) {
    v := reflect.ValueOf(o)

    if v.Kind() == reflect.Ptr && !v.Elem().CanSet() {
        fmt.Println("XXX")
        return
    } else {
        v = v.Elem()
    }
    if f := v.FieldByName("Name"); f.Kind() == reflect.String {
        f.SetString("BYE")
    }
}

// {1 BYE 20}
```

用反射调用方法：

```go
package main

import (
    "fmt"
    "reflect"
)

type User struct {
    Id   int
    Name string
    Age  int
}

func (u User) Hello(name string) {
    fmt.Println("Hello", name, ", my name is ", u.Name)
}

func main() {
    u := User{1, "OK", 20}
    v := reflect.ValueOf(u)
    mv := v.MethodByName("Hello")

    args := []reflect.Value{reflect.ValueOf("Joe")}
    mv.Call(args)
}
```

## 调试与运行时间

当您在分析和调试复杂的程序时，无数个函数在不同的代码文件中相互调用，如果这时候能够准确地知道哪个文件中的具体哪个函数正在执行，对于调试是十分有帮助的。您可以使用 `runtime` 或 `log` 包中的特殊函数来实现这样的功能。包 `runtime` 中的函数 `Caller()` 提供了相应的信息，因此可以在需要的时候实现一个 `where()` 闭包函数来打印函数执行的位置：

```go
where := func() {
    _, file, line, _ := runtime.Caller(1)
    log.Printf("%s:%d", file, line)
}
where()
// some code
where()
// some more code
where()
```

您也可以设置 `log` 包中的 flag 参数来实现：

```
log.SetFlags(log.Llongfile)
log.Print("")
```

或使用一个更加简短版本的 `where` 函数：

```go
var where = log.Print
func func1() {
where()
... some code
where()
... some code
where()
}
```

*计算函数执行时间*

```go
start := time.Now()
longCalculation()
end := time.Now()
delta := end.Sub(start)
fmt.Printf("longCalculation took this amount of time: %s\n", delta)
```
